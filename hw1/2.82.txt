A. (x<y) == (-x>-y)Does not always yields 1.  This occurs when x = INT_MIN.  Example: (INT_MIN< 5) == (INT_MIN>-5)   B.((x+y)<<4) + y-x == l7*y+15*x Always yields 1. When you shift (x+y) over 4 bits, you’re essentially multiplying x+y by 16, which results in 16*x +16*y.  Add y, subtract x, and you’ll get 17*y+15*x, which is exactly what is on the other side of the expression.

C.~x+~y+1 == ~(x+y)Always yields 1.  By two’s complement, –x = ~x+1, so ~x = -1-x. Therefore, ~x+~y+1 = -1-x +-1-y +1, and ~(x+y) = -1-(x+y).  Both sides of the expression simplify to -1 -(x+y), so therefore, they are equal.
D.(ux-uy) == -(unsigned) (y-x) Always yields 1.  When casting from signed to unsigned, the bitwise representation does not change, so the representation of ux equals the representation of x, and the representation of y equals the representation of y. This means x-y == -(y-x). 
E.((x >> 2) << 2) <= x Always yields 1. (x>>2)<<2 essentially replaces the last two digits of the binary representation with 00, which either gives us the same x (if the original binary represntation’s last two digits were 00), or a number less than x.  For positive numbers, this is because you’re actually removing 21 and 20 from the number, which naturally results in a smaller value.  For negative numbers, the formula for reading signed numbers is -2w-1 + 2w-2…20; removing 21 and 20 means that there are less positive numbers to cancel out -2w-1, resulting in a larger negative number.
F.x >> 1 == (ux >> 1) + (ux & (-1 << 31))Always yields 1. The binary representation of x is equal to ux, so the binary representation of x>>1 and ux>>1 are also equal. -1<<31 is INT_MIN, or 100000…000. If x is positive or 0, then the first digit of ux is also 0.  Therefore, when you compare ux and INT_MIN with the and operator, your result will be 00….0, or 0.  The binary representation of ux>>1 +0 is ux>>1, which is equal to x>>1.  If x is negative, then ux>>1 != x>>1, since a right shift on an unsigned integer is logical, so ux>>1 drops the sign. We add (ux & INT_MIN), which is 100…0 to bring back the sign, so x >> 1 == (ux >> 1) + (ux & (-1 << 31))
G.x % 128 == (x & 127)Does not always yields 1.  This occurs when x is negative. Example: -1%128 ==(-1&127) 